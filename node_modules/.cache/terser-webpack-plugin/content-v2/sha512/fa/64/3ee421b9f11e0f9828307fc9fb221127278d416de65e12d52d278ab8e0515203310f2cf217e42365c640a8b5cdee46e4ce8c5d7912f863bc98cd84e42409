{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{180:function(e,t,s){\"use strict\";s.r(t);var n=s(0),i=Object(n.a)({},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s(\"div\",{staticClass:\"content\"},[s(\"h1\",{attrs:{id:\"messaging-patterns\"}},[e._v(\"Messaging Patterns\")]),e._v(\" \"),s(\"p\",[e._v(\"KubeMQ supports 4 messaging patterns\")]),e._v(\" \"),e._m(0),e._v(\" \"),s(\"h2\",{attrs:{id:\"events\"}},[e._v(\"Events\")]),e._v(\" \"),s(\"p\",[e._v(\"Events is an asynchronous real-time Pub/Sub pattern.\\nIn Events multiple senders can send real-time messages to multiple receivers only if they are currently connected to KubeMQ. No message persistence available in this pattern.\")]),e._v(\" \"),e._m(1),e._v(\" \"),s(\"p\",[e._v(\"Events pattern is suitable for uses cases such publishing streaming data, logs, notifications etc.\")]),e._v(\" \"),s(\"h2\",{attrs:{id:\"events-store\"}},[e._v(\"Events Store\")]),e._v(\" \"),s(\"p\",[e._v(\"Events Store is an asynchronous Pub/Sub pattern with persistence.\\nIn Events Store multiple senders can send messages to multiple receivers even if they are not currently. Any receiver can connect to KubeMQ and replay one , any or all the messages stored for specific channel.\")]),e._v(\" \"),s(\"p\",[e._v(\"KubeMQ supports 6 types of Events Store subscriptions:\")]),e._v(\" \"),e._m(2),e._v(\" \"),e._m(3),e._v(\" \"),s(\"p\",[e._v(\"The uniqueness of client ID is important when using Events Store.\\nIn any given time, only one receiver can connect with unique Client ID. if two receivers will try to connect to KubeMQ with the same Client ID, one of them will be rejected.\")]),e._v(\" \"),e._m(4),e._v(\" \"),s(\"p\",[e._v(\"KubeMQ save for each unique Client ID the subscription type which he connected with and can replay messages only once per Client ID and Subscription type.\")]),e._v(\" \"),e._m(5),e._v(\" \"),e._m(6),e._v(\" \"),e._m(7),e._v(\" \"),s(\"p\",[e._v(\"Events Store pattern is suitable for uses cases which events are important such workers pool, chats and inbox related applications.\")]),e._v(\" \"),s(\"h2\",{attrs:{id:\"commands\"}},[e._v(\"Commands\")]),e._v(\" \"),s(\"p\",[e._v(\"Commands is a synchronous two ways Pub/Sub (Request and Response) pattern for \"),s(\"a\",{attrs:{href:\"https://martinfowler.com/bliki/CQRS.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"CQRS\"),s(\"OutboundLink\")],1),e._v(\" types of system architecture.\")]),e._v(\" \"),s(\"p\",[e._v(\"This pattern implements the Command part of \"),s(\"a\",{attrs:{href:\"https://martinfowler.com/bliki/CQRS.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"CQRS\"),s(\"OutboundLink\")],1),e._v(\" as follows:\")]),e._v(\" \"),e._m(8),e._v(\" \"),e._m(9),e._v(\" \"),s(\"p\",[e._v(\"Commands pattern is suitable for uses cases such sending updates to a DB, WebHooks or any request without the need of response in specific time.\")]),e._v(\" \"),s(\"h2\",{attrs:{id:\"queries\"}},[e._v(\"Queries\")]),e._v(\" \"),s(\"p\",[e._v(\"Queries is a synchronous two ways Pub/Sub (Request and Response) pattern for \"),s(\"a\",{attrs:{href:\"https://martinfowler.com/bliki/CQRS.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"CQRS\"),s(\"OutboundLink\")],1),e._v(\" types of system architecture.\")]),e._v(\" \"),s(\"p\",[e._v(\"This pattern implements the Query part of \"),s(\"a\",{attrs:{href:\"https://martinfowler.com/bliki/CQRS.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"CQRS\"),s(\"OutboundLink\")],1),e._v(\" as follows:\")]),e._v(\" \"),e._m(10),e._v(\" \"),e._m(11),e._v(\" \"),e._m(12),e._v(\" \"),e._m(13),e._v(\" \"),s(\"p\",[e._v(\"Queries pattern is suitable for uses cases mainly for database queries.\")]),e._v(\" \"),s(\"h2\",{attrs:{id:\"commands-vs-queries\"}},[e._v(\"Commands vs. Queries\")]),e._v(\" \"),s(\"p\",[e._v(\"Commands and Queries are very similar patterns, however, there are two differences:\")]),e._v(\" \"),e._m(14)])},[function(){var e=this.$createElement,t=this._self._c||e;return t(\"ul\",[t(\"li\",[this._v(\"Events\")]),this._v(\" \"),t(\"li\",[this._v(\"Events Store\")]),this._v(\" \"),t(\"li\",[this._v(\"Commands\")]),this._v(\" \"),t(\"li\",[this._v(\"Queries\")])])},function(){var e=this.$createElement,t=this._self._c||e;return t(\"p\",[t(\"strong\",[this._v(\"Use Cases\")])])},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s(\"table\",[s(\"thead\",[s(\"tr\",[s(\"th\",{staticStyle:{\"text-align\":\"left\"}},[e._v(\"Type\")]),e._v(\" \"),s(\"th\",{staticStyle:{\"text-align\":\"left\"}},[e._v(\"Description\")])])]),e._v(\" \"),s(\"tbody\",[s(\"tr\",[s(\"td\",{staticStyle:{\"text-align\":\"left\"}},[e._v(\"New Events\")]),e._v(\" \"),s(\"td\",{staticStyle:{\"text-align\":\"left\"}},[e._v(\"KubeMQ will send only new events\")])]),e._v(\" \"),s(\"tr\",[s(\"td\",{staticStyle:{\"text-align\":\"left\"}},[e._v(\"First Event\")]),e._v(\" \"),s(\"td\",{staticStyle:{\"text-align\":\"left\"}},[e._v(\"KubeMQ will replay all events from the first stored events and will send new events\")])]),e._v(\" \"),s(\"tr\",[s(\"td\",{staticStyle:{\"text-align\":\"left\"}},[e._v(\"Last Event\")]),e._v(\" \"),s(\"td\",{staticStyle:{\"text-align\":\"left\"}},[e._v(\"KubeMQ will replay the last event and continue to send new events\")])]),e._v(\" \"),s(\"tr\",[s(\"td\",{staticStyle:{\"text-align\":\"left\"}},[e._v(\"From Sequence\")]),e._v(\" \"),s(\"td\",{staticStyle:{\"text-align\":\"left\"}},[e._v(\"KubeMQ will replay events from specific sequence and continue to send new events\")])]),e._v(\" \"),s(\"tr\",[s(\"td\",{staticStyle:{\"text-align\":\"left\"}},[e._v(\"From Time\")]),e._v(\" \"),s(\"td\",{staticStyle:{\"text-align\":\"left\"}},[e._v(\"KubeMQ will replay events from specific time in the past and continue to send new events\")])]),e._v(\" \"),s(\"tr\",[s(\"td\",{staticStyle:{\"text-align\":\"left\"}},[e._v(\"From Time Delta\")]),e._v(\" \"),s(\"td\",{staticStyle:{\"text-align\":\"left\"}},[e._v(\"KubeMQ will replay events from specific delta of time back (i.e. 5 min back) and continue to send new events\")])])])])},function(){var e=this.$createElement,t=this._self._c||e;return t(\"p\",[t(\"strong\",[this._v(\"Unique Client ID\")])])},function(){var e=this.$createElement,t=this._self._c||e;return t(\"p\",[t(\"strong\",[this._v(\"Client ID and Subscription types Relations\")])])},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s(\"p\",[e._v(\"For example, Receiver with Client ID \"),s(\"code\",[e._v(\"client-foo-1\")]),e._v(\" subscribe to a channel \"),s(\"code\",[e._v(\"foo.bar\")]),e._v(\" in \"),s(\"code\",[e._v(\"First Event\")]),e._v(\" mode, will get all the messages stored in KubeMQ for \"),s(\"code\",[e._v(\"foo.bar\")]),e._v(\" channel from the first message and continue to get new events as they come.\\nIf this receiver will disconnect from KubeMQ and re-connect again with any subscription type, only new events in \"),s(\"code\",[e._v(\"foo.bar\")]),e._v(\" will delivered for this specific receiver with Client ID \"),s(\"code\",[e._v(\"client-foo-1\")]),e._v(\".\")])},function(){var e=this.$createElement,t=this._self._c||e;return t(\"p\",[this._v(\"If a Receiver wish to receive again the messages on \"),t(\"code\",[this._v(\"foo.bar\")]),this._v(\" he should subscribe again with different Client ID than \"),t(\"code\",[this._v(\"client-foo-1\")]),this._v(\" such \"),t(\"code\",[this._v(\"client-foo-1-retry\")]),this._v(\".\")])},function(){var e=this.$createElement,t=this._self._c||e;return t(\"p\",[t(\"strong\",[this._v(\"Use Cases\")])])},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s(\"ol\",[s(\"li\",[e._v(\"A Sender will send a Request to a channel with specific set timeout for getting a Response.\")]),e._v(\" \"),s(\"li\",[e._v(\"A Receiver will subscribe to a Channel (and Group if needed), will receive the Sender request together with unique ReplyTo channel address. This address is generated by KubeMQ.\")]),e._v(\" \"),s(\"li\",[e._v(\"A Responder (Can be either the Receiver service or a different service) will process the request and respond only if the Request was successful or not. in case of un-successful response, the responder can add an Error description into Response message.\")]),e._v(\" \"),s(\"li\",[e._v(\"The Sender will get the response from the Responder.\")]),e._v(\" \"),s(\"li\",[e._v(\"If no response will be received within the timeout that was set by the the Request, an error will be return, Timeout.\")])])},function(){var e=this.$createElement,t=this._self._c||e;return t(\"p\",[t(\"strong\",[this._v(\"Use Cases\")])])},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s(\"ol\",[s(\"li\",[e._v(\"A Sender will send a Request to a channel with specific set timeout for getting a Response.\")]),e._v(\" \"),s(\"li\",[e._v(\"A Receiver will subscribe to a Channel (and Group if needed), will receive the Sender request together with unique ReplyTo channel address. This address is generated by KubeMQ.\")]),e._v(\" \"),s(\"li\",[e._v(\"A Responder (Can be either the Receiver service or a different service) will process the request and respond with the query results (data) together with execution result and appropriate Error string in case of unsuccessful query processing.\")]),e._v(\" \"),s(\"li\",[e._v(\"The Sender will get the response from the Responder.\")]),e._v(\" \"),s(\"li\",[e._v(\"If no response will be received within the timeout that was set by the the Request, an error will be return, Timeout.\")])])},function(){var e=this.$createElement,t=this._self._c||e;return t(\"p\",[t(\"strong\",[this._v(\"Caching\")]),this._v(\"\\nKubeMQ supports caching of query results as follows:\")])},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s(\"ol\",[s(\"li\",[e._v(\"A Sender will send a Request to a channel with specific set timeout, Cache key (string) and Cache TTL (Time To Live) value (in seconds) for getting a Response.\")]),e._v(\" \"),s(\"li\",[e._v(\"KubeMQ will try to get the response results from Cache base on the Cache key.\")]),e._v(\" \"),s(\"li\",[e._v(\"If Response is stored in Cache then the sender get the response from the Cache.\")]),e._v(\" \"),s(\"li\",[e._v(\"If Response is NOT stored in Cache, KubeMQ will send the Request to available Receiver (as above)\")]),e._v(\" \"),s(\"li\",[e._v(\"Once a valid response will be received from a Responder, KubeMQ will store the Response in the Cache (with the Cache key provided by the Sender) for the time set by Cache TTL.\")]),e._v(\" \"),s(\"li\",[e._v(\"A new Request within the Cache TTL time-frame and with the same Cache key will get the same Response as stored in KubeMQ from the previous Sender Request.\")]),e._v(\" \"),s(\"li\")])},function(){var e=this.$createElement,t=this._self._c||e;return t(\"p\",[t(\"strong\",[this._v(\"Use Cases\")])])},function(){var e=this.$createElement,t=this._self._c||e;return t(\"ol\",[t(\"li\",[this._v(\"Commands Response returns only if the Request is successful or not, while Query returns with data in the Response.\")]),this._v(\" \"),t(\"li\",[this._v(\"Queries support Caching while Commands is not.\")])])}],!1,null,null,null);i.options.__file=\"concepts-messaging-patterns.md\";t.default=i.exports}}]);","extractedComments":[]}